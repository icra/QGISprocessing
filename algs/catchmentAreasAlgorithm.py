# -*- coding: utf-8 -*-

"""
/***************************************************************************
 catchmentAreas
                                 A QGIS plugin
 Create non-overlapped catchment areas for points
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-06-15
        copyright            : (C) 2021 by Josep Pueyo-Ros, ICRA
        email                : jpueyo@icra.cat
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Josep Pueyo-Ros, ICRA'
__date__ = '2021-06-15'
__copyright__ = '(C) 2021 by Josep Pueyo-Ros, ICRA'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import *
from PyQt5.QtGui import QIcon
from qgis.core import *
import qgis.utils
import processing
import os
from .utils.z_sampling import z_sampling

pluginPath = os.path.split(os.path.split(os.path.dirname(__file__))[0])[0]

class catchmentAreasAlgorithm(QgsProcessingAlgorithm):

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                'INPUT',
                self.tr('Outlets layer'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                'OUTLET_ID',
                self.tr('Field with outlets id'),
                parentLayerParameterName='INPUT',
                allowMultiple=False
            )
        )

        self.addParameter(
            QgsProcessingParameterRasterLayer(
                'DEM',
                self.tr('Filled elevations raster')
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                'OUTPUT',
                self.tr('Output layer'),
                type = QgsProcessing.TypeVectorPolygon
            )
        )

    def processAlgorithm(self, parameters, context, feedback):

        input = self.parameterAsVectorLayer(parameters, 'INPUT', context)
        dem = self.parameterAsRasterLayer(parameters, 'DEM', context)
        outlet_id = self.parameterAsString(parameters, 'OUTLET_ID', context)

        field = QgsFields()
        id = QgsField("outlet_id", QVariant.String)
        field.append(id)

        (sink, dest_id) = self.parameterAsSink(parameters, 'OUTPUT',
                context, field, QgsWkbTypes.Polygon, input.sourceCrs())

        total_points = input.featureCount()

        if input.fields().indexFromName('z') == -1:
            outlets = z_sampling(input, dem, feedback)
        else:
            outlets = input

        request = QgsFeatureRequest()

        # set order by field
        clause = request.OrderByClause('z', ascending=False)
        orderby = request.OrderBy([clause])
        request.setOrderBy(orderby)

        features = outlets.getFeatures(request)

        catchments = QgsVectorLayer("Polygon", "catchments", "memory")
        catchments_data = catchments.dataProvider()
        catchments_data.addAttributes([id])
        catchments.updateFields()
        feedback.setProgressText("Fields in catchments are {}".format(catchments_data.fields().toList()))

        # Iterate over point features
        for i, pnt in enumerate(features):

            # Get x and y coordinate from point feature
            geom = pnt.geometry()
            p = geom.asPoint()
            x = p.x()
            y = p.y()

            feedback.pushInfo('Creating upslope area for outlet id {} - {} of {}'.format(pnt[outlet_id], i + 1, total_points))
            feedback.setProgress(i / total_points * 100)

            pnt_outlet_id = str(pnt[outlet_id])

            # Calculate catchment raster from point feature
            catchraster = processing.run("saga:upslopearea", {'TARGET':None,
                                        'TARGET_PT_X':x,
                                        'TARGET_PT_Y':y,
                                        'ELEVATION': dem,
                                        'SINKROUTE': None,
                                        'METHOD':0, 'CONVERGE':1.1,
                                        'AREA': 'TEMPORARY_OUTPUT'})
            # feedback.pushInfo('Catchment area created: ' + str(catchraster['AREA']))
            # Polygonize raster catchment
            catchpoly = processing.run("gdal:polygonize", {'INPUT':catchraster['AREA'],
                                        'BAND':1,
                                        'FIELD':'DN',
                                        'EIGHT_CONNECTEDNESS':False,
                                        'OUTPUT': 'TEMPORARY_OUTPUT'})

            # feedback.pushInfo('Catchment area polygonized: ' + str(catchpoly['OUTPUT']))
            # Select features having DN = 100 and export them to a SHP file
            catch_lyr = QgsVectorLayer(catchpoly['OUTPUT'], 'catchmments', 'ogr')
            catch_lyr.dataProvider().addAttributes([id])
            catch_lyr.updateFields()


            exp = QgsExpression('"DN"=100')
            request = QgsFeatureRequest(exp)
            features = catch_lyr.getFeatures(request)


            # feedback.setProgressText("The fields in catchments are {}".format(catchments.fields().toList()))

            #in first slope, just add feature to sink, then, first avoid overlapping with previous areas
            if catchments.featureCount() > 0:
                catchment = QgsVectorLayer("Polygon", "duplicated_layer", "memory")
                catchment_data = catchment.dataProvider()
                attr = catch_lyr.dataProvider().fields().toList()
                catchment_data.addAttributes(attr)
                catchment.updateFields()
                catchment_data.addFeatures(features)
                feedback.setProgressText('Inside if')


                catchment_final = processing.run('native:difference',{
                    'INPUT': catchment,
                    'OVERLAY': catchments,
                    'OUTPUT': 'memory:'
                    })['OUTPUT']
                # add catchment area to output
                for feature in catchment_final.getFeatures():
                    feature['outlet_id'] = pnt_outlet_id
                    catchments.dataProvider().addFeature(feature)
                    feedback.setProgressText('Inside if. Oulet_id is {}'.format(pnt_outlet_id))
            else:
                fList = []
                for feature in features:
                    feature['outlet_id'] = pnt_outlet_id
                    feedback.setProgressText("Feature is {}".format(feature['outlet_id']))
                    fList.append(feature)

                catchments.dataProvider().addFeatures(fList)
                catchments.commitChanges()

        for feature in catchments.getFeatures():
            feedback.setProgressText("Adding to sink. Feature outlet_id is {}".format(feature['outlet_id']))
            sink.addFeature(feature, QgsFeatureSink.FastInsert)

        return {'OUTPUT': dest_id}

    def name(self):

        return 'catchment areas'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    # def group(self):
    #     """
    #     Returns the name of the group this algorithm belongs to. This string
    #     should be localised.
    #     """
    #     return self.tr(self.groupId())
    #
    # def groupId(self):
    #     """
    #     Returns the unique ID of the group this algorithm belongs to. This
    #     string should be fixed for the algorithm, and must not be localised.
    #     The group id should be unique within each provider. Group id should
    #     contain lowercase alphanumeric characters only and no spaces or other
    #     formatting characters.
    #     """
    #     return 'Sewer system'

    def icon(self):
        return QIcon(os.path.join(pluginPath, 'ICRA', 'icons', 'buildings2sewer.png'))

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return catchmentAreasAlgorithm()

    def shortHelpString(self):
        return "<p>This algorithm connects the buildings of a city to the manholes of the sewer system. It connects each building (using the centroid as a departure point) to the closest manhole that is in the same or in a lower altitude.</p>"\
        "<p>It returns the centroids of the buildings with the following fields:"\
        "<ul><li>Id of the manhole which the building is connected</li><li>Altitude of the building's centroid</li><li>Distance between the building's centroid and the connected manhole</li>"\
        "<li>Altitude difference between the building's centroid and the connected manhole</li></ul>"\
        "If \"Create connection lines is checked\", it also returns a layer with the lines showing each connection.</p>"\
        "<p>Two parameters can be adjusted:<ul>"\
        "<li> <b>Maximum distance:</b> If a connection is larger than the maximum distance, the algorithm searches manholes 1 meter above. This iteration is repeated until the connection is shorter than the maximum distance or until the altitude tolerance is reached </li>"\
        "<li> <b>Altitude tolerance:</b> It determines how many meters upper a manhole can be regarding the building to connect. The altitude tolerance is only used when the maximum distance is surpassed</li>"\
        "</ul></p>"
